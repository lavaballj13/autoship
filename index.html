<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Fleet Battle Prototype - Drag & Card Upgrades</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root {
    --bg:#0b1420; --panel:#111e2c; --accent:#3fa9f5; --accent2:#4cd2b8; --danger:#e25d5d; --warn:#f0c05a; --ok:#53c97d;
    --battle-w: 1080px; --battle-h: 460px;
    font-family: system-ui, "Segoe UI", Roboto, Arial, sans-serif;
  }
  * { box-sizing:border-box; }
  body { margin:0; background:var(--bg); color:#e9f4ff; display:flex; flex-direction:column; min-height:100vh; }
  header { padding:8px 14px; background:#08111b; font-size:14px; letter-spacing:.5px; display:flex; justify-content:space-between; align-items:center; }
  header h1 { margin:0; font-size:16px; font-weight:600; }
  #battleWrapper { margin:8px auto 0; width:var(--battle-w); position:relative; }
  #battleCanvas { background:#091722; width:100%; height:var(--battle-h); border:6px solid #0d2536; display:block; }
  #bottomBar { width:var(--battle-w); margin:0 auto; background:var(--panel); border:4px solid #0d2536; display:flex; flex-direction:column; padding:6px 10px 10px; gap:8px; }
  #cardTray { display:flex; gap:12px; overflow-x:auto; padding:4px 4px 8px; }
  .card { flex:0 0 140px; background:#0e1f2d; border:2px solid #1f3d54; border-radius:10px; padding:8px 8px 10px; position:relative; cursor:grab; user-select:none; }
  .card.dragging { opacity:.4; cursor:grabbing; }
  .card h4 { margin:0 0 4px; font-size:13px; letter-spacing:.5px; }
  .card small { font-size:11px; line-height:1.25; opacity:.85; }
  .rarity-common { border-color:#33536e; }
  .rarity-rare { border-color:#3fa9f5; box-shadow:0 0 0 1px #3fa9f5aa; }
  .rarity-epic { border-color:#c06bff; box-shadow:0 0 0 2px #c06bffaa; }

  #infoBar { display:flex; gap:16px; flex-wrap:wrap; font-size:12px; }
  #timer { font-weight:600; }
  #status { flex:1; }
  #shipStatsPanel { width:var(--battle-w); margin:6px auto 0; display:grid; grid-template-columns:repeat(auto-fit,minmax(170px,1fr)); gap:8px; }
  .shipStatsCard { background:#0e1f2d; border:2px solid #1f3d54; border-radius:8px; padding:6px 8px 8px; font-size:11px; position:relative; }
  .shipStatsCard .title { font-weight:600; font-size:12px; margin-bottom:2px; }
  .shipStatsCard .tier { font-size:10px; opacity:.8; }
  .shipStatsCard.drag-target { outline:2px dashed var(--accent); }
  .shipStatsCard.drag-card-hover { background:#142d3c; }
  .upgradePulse { animation:upPulse 1s ease-out; }
  @keyframes upPulse { 0%{box-shadow:0 0 0 0 rgba(79,243,180,.7);} 70%{box-shadow:0 0 0 14px rgba(79,243,180,0);} 100%{box-shadow:0 0 0 0 rgba(79,243,180,0);} }

  button { background:var(--accent); border:none; color:#04131f; padding:6px 10px; font-weight:600; border-radius:5px; cursor:pointer; font-size:12px; }
  button:disabled { opacity:.45; cursor:not-allowed; }
  #overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; backdrop-filter:blur(3px); background:rgba(0,0,0,.55); }
  #overlay .inner { background:#0f2231; padding:28px 34px; border:2px solid var(--accent); border-radius:14px; text-align:center; width:380px; }
  #overlay h2 { margin-top:0; }
  canvas { image-rendering:pixelated; }
  #legend { margin:2px auto 4px; width:var(--battle-w); font-size:11px; opacity:.65; display:flex; justify-content:space-between; }
  #legend span { margin-right:18px; }
</style>
</head>
<body>
<header>
  <h1>Fleet Battle (Drag & Upgrade)</h1>
  <div id="headerControls">
    <button id="btnStart">Start Battle</button>
    <button id="btnReset" disabled>Reset</button>
  </div>
</header>
<div id="battleWrapper">
  <canvas id="battleCanvas" width="1080" height="460"></canvas>
</div>
<div id="legend"><span>Drag ships (before battle) to reposition • Drag cards onto ships to apply upgrades</span><span id="timer">00.0s</span></div>
<div id="shipStatsPanel"></div>
<div id="bottomBar">
  <div id="cardTray"></div>
  <div id="infoBar"><div id="status">Ready.</div><div>Fire Rate ↓ upgrades are multiplicative.</div></div>
</div>
<div id="overlay"><div class="inner"><h2 id="resultTitle">Victory</h2><p id="resultStats"></p><button id="btnCloseOverlay">Close</button></div></div>
<script>
/* =============================================================
   Drag & Card Upgrade Prototype (Stationary)
   NEW FEATURES vs previous:
     - Drag player ships to reposition BEFORE battle (snap to nearest lane column slot).
     - Card tray with upgrade "cards" rendered as playing cards.
     - Drag & drop card onto shipStatsCard OR ship on canvas to apply.
     - Duplicate ship blueprints accumulate; when a threshold met => FUSION upgrade (Tier++).
     - Ship stats panel updates dynamically (HP, DMG, Fire Rate, Tier, Applied Mods).
     - Visual pulse on upgrade / fusion.
   ============================================================= */

/***************** CONFIG *****************/
const CONFIG = {
  lanes: 5,
  width: 1080,
  height: 460,
  playerX: 150,
  enemyX: 930,
  projectileSpeed: 430,
  frameRate: 60,
  lanePaddingY: 36,
  cardFusionThreshold: 2, // number of blueprint duplicates consumed to tier-up (after first) => Tier I + 2 duplicates -> Tier II; needs +2 more -> Tier III
  fireRatePenaltyPerTier: 0.90, // multiply base fireRate each tier (lower = faster)
  hpTierMult: 1.55,
  dmgTierMult: 1.35,
  damageFlash: 120,
  reloadRadius: 30,
  shipWidth: 90,
  shipHeight: 34,
  dragSnapXSpacing: 74,     // horizontal snap grid spacing between columns for player side
  dragColumns: 5,            // # columns allowed for player positions
  playerMinX: 100,
  enemyMinX: 930,
  columnSpacing: 74,
};

/***************** DATA *****************/
const PLAYER_SHIP_DEFS = [
  { id:'rammer',  name:'Rammer',  lane:0, hp:320, dmg:26, fireRate:1150, color:'#3fa9f5' },
  { id:'archer',  name:'Archer',  lane:2, hp:220, dmg:34, fireRate:1400, color:'#8fd7ff' },
  { id:'support', name:'Support', lane:4, hp:250, dmg:18, fireRate:900,  color:'#4cd2b8' }
];
const ENEMY_SHIP_DEFS = [
  { id:'raider',  name:'Raider',  lane:0, hp:260, dmg:22, fireRate:1300, color:'#e25d5d' },
  { id:'corsair', name:'Corsair', lane:2, hp:230, dmg:28, fireRate:1500, color:'#f07f5a' },
  { id:'bomber',  name:'Bomber',  lane:4, hp:285, dmg:20, fireRate:1000, color:'#ffb347' }
];

// Card definitions: type influences effect application.
// blueprint-random duplicates grant potential fusion; mod-fire-rate; mod-damage; mod-repair; mod-hp;
const CARD_LIBRARY = [
  { id:'bp_rammer',  type:'blueprint', hullId:'rammer',  name:'Blueprint: Rammer', text:'+1 Rammer duplicate (collect to Fuse)', rarity:'common' },
  { id:'bp_archer',  type:'blueprint', hullId:'archer',  name:'Blueprint: Archer', text:'+1 Archer duplicate', rarity:'common' },
  { id:'bp_support', type:'blueprint', hullId:'support', name:'Blueprint: Support', text:'+1 Support duplicate', rarity:'common' },
  { id:'up_firerate', type:'mod', mod:{ fireRateMult:0.92 }, name:'Gunner Drill', text:'Fire Rate +8% (mult)', rarity:'common' },
  { id:'up_damage',   type:'mod', mod:{ dmgMult:1.10 }, name:'Hot Shot', text:'+10% Damage', rarity:'rare' },
  { id:'up_hull',     type:'mod', mod:{ hpMult:1.15 }, name:'Reinforce Hull', text:'+15% Max HP', rarity:'common' },
  { id:'up_repair',   type:'instant', effect:'repair15', name:'Field Repair', text:'Restore 15% HP now', rarity:'common' },
  { id:'up_overload', type:'mod', mod:{ dmgMult:1.20, fireRateMult:0.95 }, name:'Overload Cannons', text:'+20% Dmg, +5% fire rate', rarity:'epic' }
];

/***************** STATE *****************/
const state = {
  phase:'idle',
  ships:[],
  projectiles:[],
  cards:[],            // deck/tray (simple pool for now)
  heldCard:null,       // current dragging card object
  dragOffset:{x:0,y:0},
  shipBlueprintCounts:{}, // counts per hullId
  lastTime:0,
  startTime:0,
  elapsed:0,
};

/***************** SETUP *****************/
function setup(){
  state.phase='idle';
  state.ships = [];
  uidCounter=1;
  PLAYER_SHIP_DEFS.forEach(d=> state.ships.push(makeShip(d,'player')));
  ENEMY_SHIP_DEFS.forEach(d=> state.ships.push(makeShip(d,'enemy')));
  state.projectiles = [];
  state.cards = generateInitialCards();
  state.shipBlueprintCounts = { rammer:0, archer:0, support:0 };
  state.heldCard=null; state.elapsed=0; updateStatus('Arrange & upgrade.');
  renderCardTray();
  updateShipStatsPanel();
  draw();
}

function generateInitialCards(){
  // Provide some initial random cards (8) including a few blueprints.
  const picks=[];
  const pool = [...CARD_LIBRARY];
  for (let i=0;i<8;i++) picks.push(pool[Math.floor(Math.random()*pool.length)]);
  return picks.map(c=> ({...c, instanceId: c.id + '_' + Math.random().toString(36).slice(2)}));
}

/***************** SHIP / COMBAT LOGIC *****************/
let uidCounter=1;
function makeShip(def, side){
  return {
    uid: (side==='player'? 'P':'E')+(uidCounter++),
    side,
    id:def.id,
    name:def.name,
    baseHP:def.hp,
    baseDmg:def.dmg,
    baseFireRate:def.fireRate,
    color:def.color,
    lane:def.lane,
    tier:1,
    hp:def.hp,
    dmgMod:1,
    fireRateMod:1,
    hpMod:1,
    mods:[],  // textual tags of applied mods
    fireTimer:0,
    flashT:0,
    alive:true,
    x: side==='player'? computePlayerX(2) : CONFIG.enemyX, // default col 2 center
    y: laneToY(def.lane),
    dragging:false
  };
}
function computePlayerX(col){
  return CONFIG.playerMinX + col * CONFIG.columnSpacing;
}
function laneToY(lane){
  const top = CONFIG.lanePaddingY;
  const usable = CONFIG.height - CONFIG.lanePaddingY*2;
  const spacing = usable / (CONFIG.lanes-1);
  return top + lane*spacing;
}

function fireCooldown(ship){
  return ship.baseFireRate * ship.fireRateMod * Math.pow(CONFIG.fireRatePenaltyPerTier, ship.tier-1);
}
function effectiveDamage(ship){
  return Math.round(ship.baseDmg * ship.dmgMod * Math.pow(CONFIG.dmgTierMult, ship.tier-1));
}
function effectiveMaxHP(ship){
  return Math.round(ship.baseHP * ship.hpMod * Math.pow(CONFIG.hpTierMult, ship.tier-1));
}

function nearestEnemy(ship){
  let best=null, bestDist=Infinity;
  for (const o of state.ships){
    if (!o.alive || o.side===ship.side) continue;
    const dx = o.x - ship.x; const dy=o.y - ship.y; const dist = Math.hypot(dx,dy) + (o.lane===ship.lane? -20:0);
    if (dist < bestDist){ bestDist=dist; best=o; }
  }
  return best;
}

function makeProjectile(from, target){
  const ang = Math.atan2(target.y - from.y, target.x - from.x);
  return { x:from.x, y:from.y, vx:Math.cos(ang)*CONFIG.projectileSpeed, vy:Math.sin(ang)*CONFIG.projectileSpeed, r:4, from:from.uid, target:target.uid, color: from.side==='player'? '#a9f3ff':'#ff9f84', alive:true };
}

function updateBattle(dt){
  for (const s of state.ships){
    if (!s.alive || s.side==='enemy') continue; // player fire cycle first (order not critical here)
  }
  // Update timers & fire
  for (const s of state.ships){
    if (!s.alive) continue;
    s.fireTimer += dt;
    s.flashT = Math.max(0, s.flashT - dt);
    const cd = fireCooldown(s);
    if (state.phase==='running' && s.fireTimer >= cd){
      const target = nearestEnemy(s);
      if (target){
        s.fireTimer = 0;
        state.projectiles.push(makeProjectile(s,target));
      }
    }
  }
  // Projectiles
  for (const p of state.projectiles){
    if (!p.alive) continue;
    p.x += p.vx * dt/1000; p.y += p.vy * dt/1000;
    const target = state.ships.find(s=> s.uid===p.target && s.alive);
    if (!target){ p.alive=false; continue; }
    const dx = target.x - p.x; const dy = target.y - p.y; if (Math.hypot(dx,dy) < 12){
      const shooter = state.ships.find(s=> s.uid===p.from);
      const dmg = shooter? effectiveDamage(shooter):25;
      dealDamage(target,dmg);
      p.alive=false;
    }
  }
  state.projectiles = state.projectiles.filter(p=>p.alive);
  // Win/Lose
  const playerAlive = state.ships.some(s=> s.side==='player' && s.alive);
  const enemyAlive = state.ships.some(s=> s.side==='enemy' && s.alive);
  if (!enemyAlive) endBattle(true); else if (!playerAlive) endBattle(false);
}
function dealDamage(ship, amt){
  ship.hp -= amt; ship.flashT = CONFIG.damageFlash;
  if (ship.hp <= 0){ ship.alive=false; ship.hp=0; }
  updateShipStatsPanel();
}

/***************** FUSION / DUPLICATE HANDLING *****************/
function addBlueprint(hullId){
  state.shipBlueprintCounts[hullId] = (state.shipBlueprintCounts[hullId] || 0) + 1;
  checkFusion(hullId);
  updateShipStatsPanel();
}
function checkFusion(hullId){
  const ship = state.ships.find(s=> s.side==='player' && s.id===hullId);
  if (!ship) return;
  const needed = CONFIG.cardFusionThreshold;
  // For each tier beyond 1, we consume 'needed' duplicates.
  while (ship.tier < 3 && state.shipBlueprintCounts[hullId] >= needed){
    state.shipBlueprintCounts[hullId] -= needed;
    ship.tier++;
    // Heal to new max
    ship.hp = effectiveMaxHP(ship);
    pulseShipCard(ship.uid);
    updateStatus(`${ship.name} fused to Tier ${ship.tier}!`);
  }
}
function pulseShipCard(uid){
  const el = document.querySelector(`.shipStatsCard[data-uid='${uid}']`);
  if (el){ el.classList.add('upgradePulse'); setTimeout(()=> el.classList.remove('upgradePulse'), 1100); }
}

/***************** APPLY CARD EFFECT *****************/
function applyCardToShip(card, ship){
  if (!ship || !ship.alive) return;
  if (card.type==='blueprint'){
    addBlueprint(card.hullId);
  } else if (card.type==='mod'){
    if (card.mod.fireRateMult){ ship.fireRateMod *= card.mod.fireRateMult; ship.mods.push('FR'); }
    if (card.mod.dmgMult){ ship.dmgMod *= card.mod.dmgMult; ship.mods.push('DMG'); }
    if (card.mod.hpMult){
      const prevMax = effectiveMaxHP(ship);
      ship.hpMod *= card.mod.hpMult; ship.mods.push('HP');
      const newMax = effectiveMaxHP(ship);
      // Increase current HP proportionally
      ship.hp += (newMax - prevMax);
    }
    updateStatus(`${card.name} applied to ${ship.name}`);
  } else if (card.type==='instant'){
    if (card.effect==='repair15'){
      const max = effectiveMaxHP(ship);
      ship.hp = Math.min(max, ship.hp + Math.round(max*0.15));
      updateStatus(`${ship.name} repaired`);
    }
  }
  removeCardInstance(card.instanceId);
  updateShipStatsPanel();
}
function removeCardInstance(instanceId){
  state.cards = state.cards.filter(c=> c.instanceId!==instanceId);
  renderCardTray();
}

/***************** DRAG & DROP (Cards) *****************/
let dragCardEl=null; let dragCardData=null;
function renderCardTray(){
  const tray = document.getElementById('cardTray');
  tray.innerHTML='';
  state.cards.forEach(card => {
    const el = document.createElement('div');
    el.className = `card rarity-${card.rarity}`;
    el.draggable = true;
    el.dataset.instanceId = card.instanceId;
    el.innerHTML = `<h4>${card.name}</h4><small>${card.text}</small>`;
    el.addEventListener('dragstart', e=> onCardDragStart(e, card));
    el.addEventListener('dragend', onCardDragEnd);
    tray.appendChild(el);
  });
}
function onCardDragStart(e, card){
  dragCardEl = e.currentTarget; dragCardData = card; dragCardEl.classList.add('dragging');
  e.dataTransfer.effectAllowed='copy';
}
function onCardDragEnd(){ if (dragCardEl) dragCardEl.classList.remove('dragging'); dragCardEl=null; dragCardData=null; }

// Allow drop on ship stat cards and canvas ship hitboxes
function setupShipDropZones(){
  document.getElementById('shipStatsPanel').addEventListener('dragover', e=>{
    if (!dragCardData) return; const target = e.target.closest('.shipStatsCard'); if (!target) return;
    e.preventDefault(); target.classList.add('drag-card-hover');
  });
  document.getElementById('shipStatsPanel').addEventListener('dragleave', e=>{
    const target = e.target.closest('.shipStatsCard'); if (target) target.classList.remove('drag-card-hover');
  });
  document.getElementById('shipStatsPanel').addEventListener('drop', e=>{
    const target = e.target.closest('.shipStatsCard'); if (!target || !dragCardData) return;
    e.preventDefault(); target.classList.remove('drag-card-hover');
    const uid = target.dataset.uid; const ship = state.ships.find(s=> s.uid===uid);
    applyCardToShip(dragCardData, ship); onCardDragEnd();
  });
}

/***************** DRAG SHIPS (REPOSITION) *****************/
let draggingShip=null; let dragShipOffset={x:0,y:0};
function enableCanvasDrag(){
  battleCanvas.addEventListener('mousedown', e=>{
    if (state.phase!=='idle') return; // only before battle
    const ship = pickPlayerShipAt(e.offsetX, e.offsetY);
    if (ship){ draggingShip = ship; ship.dragging=true; dragShipOffset.x = e.offsetX - ship.x; dragShipOffset.y = e.offsetY - ship.y; }
  });
  window.addEventListener('mousemove', e=>{
    if (!draggingShip) return; const rect = battleCanvas.getBoundingClientRect();
    let x = e.clientX - rect.left - dragShipOffset.x; let y = e.clientY - rect.top - dragShipOffset.y;
    // Snap y to nearest lane center
    const lane = Math.round((y - CONFIG.lanePaddingY) / ((CONFIG.height - CONFIG.lanePaddingY*2)/(CONFIG.lanes-1)));
    draggingShip.lane = clamp(lane,0,CONFIG.lanes-1);
    draggingShip.y = laneToY(draggingShip.lane);
    // Snap x to nearest player column
    const relX = clamp(x, CONFIG.playerMinX - CONFIG.columnSpacing, CONFIG.playerMinX + (CONFIG.dragColumns-1)*CONFIG.columnSpacing + CONFIG.columnSpacing/2);
    const col = Math.round((relX - CONFIG.playerMinX)/CONFIG.columnSpacing);
    draggingShip.x = computePlayerX(clamp(col,0,CONFIG.dragColumns-1));
    draw();
  });
  window.addEventListener('mouseup', ()=>{ if (draggingShip){ draggingShip.dragging=false; draggingShip=null; } });
}
function pickPlayerShipAt(x,y){
  return state.ships.find(s=> s.side==='player' && s.alive && Math.abs(x - s.x) < CONFIG.shipWidth/2 && Math.abs(y - s.y) < CONFIG.shipHeight/2);
}

/***************** SHIP STATS PANEL *****************/
function updateShipStatsPanel(){
  const panel = document.getElementById('shipStatsPanel');
  panel.innerHTML='';
  state.ships.filter(s=> s.side==='player').forEach(s=> {
    const maxHP = effectiveMaxHP(s);
    const card = document.createElement('div');
    card.className='shipStatsCard'; card.dataset.uid=s.uid; card.innerHTML=`
      <div class="title">${s.name}</div>
      <div class="tier">Tier ${s.tier} ${s.mods.length? '• Mods: '+s.mods.join(', '):''}</div>
      HP: ${s.hp}/${maxHP}<br>
      DMG: ${effectiveDamage(s)}<br>
      Fire CD: ${Math.round(fireCooldown(s))}ms<br>
      Blueprints: ${state.shipBlueprintCounts[s.id]||0}
    `;
    panel.appendChild(card);
  });
}

/***************** BATTLE LOOP *****************/
let rafId=null; const battleCanvas=document.getElementById('battleCanvas'); const ctx=battleCanvas.getContext('2d');
function startBattle(){
  if (state.phase!=='idle') return;
  state.phase='running';
  state.startTime = performance.now(); state.lastTime = state.startTime; updateStatus('Battle running...');
  rafId = requestAnimationFrame(loop);
}
function loop(t){
  if (state.phase!=='running') return;
  const dt = t - state.lastTime; state.lastTime = t; state.elapsed = t - state.startTime; updateTimer();
  updateBattle(dt); draw(); rafId = requestAnimationFrame(loop);
}
function endBattle(victory){
  state.phase='ended'; cancelAnimationFrame(rafId); updateStatus(victory? 'Victory!':'Defeat');
  showOverlay(victory);
  document.getElementById('btnReset').disabled=false;
}
function updateTimer(){ document.getElementById('timer').textContent = (state.elapsed/1000).toFixed(1)+'s'; }
function updateStatus(msg){ document.getElementById('status').textContent = msg; }

/***************** RENDERING *****************/
function draw(){
  ctx.clearRect(0,0,CONFIG.width,CONFIG.height);
  drawLaneGuides();
  drawProjectiles();
  drawShips();
}
function drawLaneGuides(){
  ctx.save(); ctx.strokeStyle='#142b3c'; ctx.lineWidth=1; ctx.setLineDash([6,10]);
  for (let l=0;l<CONFIG.lanes;l++){ const y=laneToY(l); ctx.beginPath(); ctx.moveTo(60,y); ctx.lineTo(CONFIG.width-60,y); ctx.stroke(); }
  ctx.restore();
}
function drawShips(){
  for (const s of state.ships){ drawShip(s); }
}
function drawShip(ship){
  const {x,y} = ship; const w=CONFIG.shipWidth; const h=CONFIG.shipHeight; ctx.save(); ctx.translate(x,y);
  ctx.globalAlpha = ship.alive?1:0.25;
  const flashA = ship.flashT>0? ship.flashT/CONFIG.damageFlash : 0;
  ctx.fillStyle = blend(ship.color,'#ffffff', flashA*0.85);
  roundRect(-w/2,-h/2,w,h,8); ctx.fill(); ctx.strokeStyle='#0d2536'; ctx.lineWidth=2; ctx.stroke();
  // name
  ctx.fillStyle='#fff'; ctx.font='11px sans-serif'; ctx.textAlign='center'; ctx.fillText(ship.name,0,-h/2-8);
  // HP bar
  drawHPBar(ship);
  // Reload circle
  if (ship.alive && state.phase==='running'){
    const cd = fireCooldown(ship); const frac = Math.min(1, ship.fireTimer / cd);
    drawReload(frac, ship.side==='player');
  } else if (ship.alive && state.phase==='idle') {
    drawReload(1, ship.side==='player', 0.15); // show full (ready)
  }
  ctx.restore();
}
function drawHPBar(ship){
  const pct = ship.hp / effectiveMaxHP(ship); const w=74, h=6; ctx.save(); ctx.translate(0,22);
  ctx.fillStyle='#1d3544'; ctx.fillRect(-w/2,-h/2,w,h);
  ctx.fillStyle = pct>0.6? '#53c97d' : pct>0.3? '#f0c05a':'#e25d5d'; ctx.fillRect(-w/2,-h/2,w*pct,h);
  ctx.strokeStyle='#0a1b27'; ctx.strokeRect(-w/2,-h/2,w,h); ctx.restore();
}
function drawReload(frac, playerSide, alphaOverride){
  const r=CONFIG.reloadRadius; ctx.save(); ctx.beginPath(); ctx.strokeStyle=playerSide?'#3fa9f5':'#ff8866'; ctx.lineWidth=3; ctx.globalAlpha = alphaOverride || 1; ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,0); ctx.fillStyle=playerSide?'rgba(63,169,245,0.3)':'rgba(255,136,102,0.3)'; ctx.arc(0,0,r,-Math.PI/2,-Math.PI/2 + Math.PI*2*frac); ctx.closePath(); ctx.fill(); ctx.restore();
}
function drawProjectiles(){ ctx.save(); for (const p of state.projectiles){ ctx.beginPath(); ctx.fillStyle=p.color; ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); } ctx.restore(); }
function blend(a,b,t){ const A=hexToRgb(a), B=hexToRgb(b); const r=Math.round(A.r+(B.r-A.r)*t), g=Math.round(A.g+(B.g-A.g)*t), c=Math.round(A.b+(B.b-A.b)*t); return `rgb(${r},${g},${c})`; }
function hexToRgb(h){ return { r:parseInt(h.slice(1,3),16), g:parseInt(h.slice(3,5),16), b:parseInt(h.slice(5,7),16) }; }
function roundRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r); ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h); ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r); ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath(); }

/***************** OVERLAY *****************/
function showOverlay(v){ const ov=document.getElementById('overlay'); ov.style.display='flex'; document.getElementById('resultTitle').textContent=v?'Victory!':'Defeat'; document.getElementById('resultStats').textContent = 'Duration: '+(state.elapsed/1000).toFixed(1)+'s'; }
function closeOverlay(){ document.getElementById('overlay').style.display='none'; }

/***************** EVENTS *****************/
window.addEventListener('DOMContentLoaded', ()=>{
  setup(); setupShipDropZones(); enableCanvasDrag();
  document.getElementById('btnStart').addEventListener('click', startBattle);
  document.getElementById('btnReset').addEventListener('click', ()=> { closeOverlay(); setup(); document.getElementById('btnReset').disabled=true; });
  document.getElementById('btnCloseOverlay').addEventListener('click', ()=> closeOverlay());
});

</script>
</body>
</html>
